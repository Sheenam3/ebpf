#!/usr/bin/python
#To get func count value of one function only
#the following code provides every 1 second number count of specified function
'''root@master:/usr/share/bcc/tools# ./functest -i 1 -s /usr/share/bcc/tools/usimex -fn goNum
FUNC                                    COUNT
goNum                                   11280
goNum                                    7554
goNum                                    7533
goNum                                   11486
^Cuprobes before detaching: 1
uprobes after detaching: 0 '''
#Modified by: Sheenam 06-Jan-2022
from bcc import BPF
import argparse
from time import sleep, strftime
from signal import SIGINT, signal, SIGTERM
examples = """examples:
    ./functime           # time functime calls
    ./functime -p 181    # only trace PID 181
"""
parser = argparse.ArgumentParser(
    description="Show time for user function",
    formatter_class=argparse.RawDescriptionHelpFormatter,
    epilog=examples)
parser.add_argument("-p", "--pid", help="trace this PID only", type=int,
    default=-1)
parser.add_argument("-s", "--shared", nargs="?",
        help="specify file path")
parser.add_argument("-fn", "--fn", nargs="?",
        help="specify function name")
parser.add_argument("-i", "--interval",
        help="summary interval, seconds")
args = parser.parse_args()
if not args.interval:
            args.interval = 99999999
name = args.shared if args.shared else "not valid file path"
fname = args.fn if args.fn else "Please enter the function name"
matched = 0
trace_functions = {}
t = 1
# load BPF program
bpf_text = b"""#include <uapi/linux/ptrace.h>
BPF_ARRAY(counts, u64, 1);
int trace_count(void *ctx) {
    int loc = 0;
    u64 *val = counts.lookup(&loc);
    if (!val) {
        return 0;   // Should never happen, # of locations is known
    }
    (*val)++;
    return 0;
}
"""
if args.ebpf:
    print(bpf_text)
    exit()
trace_functions[matched] = fname
b = BPF(text=bpf_text)
b.attach_uprobe(name=name, sym=fname, fn_name="trace_count", pid=args.pid or -1)

def counts():
        return b["counts"]
def clear():
        counts = b["counts"]
        counts[counts.Key(0)] = counts.Leaf()

print("%-36s %8s" % ("FUNC", "COUNT"))

def handler(signal_received, frame):
    # Handle any cleanup here
     b.detach_uprobe(name=name, sym=fname)
     exit()

signal(SIGINT, handler)

exiting = 0
seconds = 0

while t:
    try:
        
        sleep(int(args.interval))
        seconds += int(args.interval)
        count = counts()
        for _, v in sorted(count.items(),
                               key=lambda count: count[0].value):
                print("%-36s %8d" % (fname, v.value))
                clear()
    


    except KeyboardInterrupt:
        exiting = 1
    if exiting:
        print("Detaching...")
        exit()
